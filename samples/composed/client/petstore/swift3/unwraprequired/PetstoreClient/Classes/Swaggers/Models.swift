// Models.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case HttpError(statusCode: Int, data: Data?, error: Error)
    case DecodeError(response: Data?, decodeError: DecodeError)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for case let (key, value) as (String, String) in rawHeader {
            header[key] = value
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

public enum Decoded<ValueType> {
    case success(ValueType)
    case failure(DecodeError)
}

public extension Decoded {
    var value: ValueType? {
        switch self {
        case let .success(value):
            return value
        case .failure:
            return nil
        }
    }
}

public enum DecodeError {
    case typeMismatch(expected: String, actual: String)
    case missingKey(key: String)
    case parseError(message: String)
}

private var once = Int()
class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject, AnyObject?) -> AnyObject)>()

    static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0, $1) as AnyObject }
    }

    static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
        let key = discriminator
        if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
            return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
        if let sourceArray = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in sourceArray {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value):
                    values.append(value)
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        switch Decoders.decode(clazz: T.self, source: source, instance: nil) {
    	    case let .success(value):
                return .success(value)
            case let .failure(error):
                return .failure(error)
        }
    }

    static open func decode<T: RawRepresentable>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value):
                    dictionary[key] = value
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        guard !(source is NSNull), source != nil else { return .success(nil) }
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
        initialize()
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int32.Type {
            return .success(value)
        }
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int64.Type {
     	    return .success(value)
        }
        if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
            return .success(value)
        }
        if let value = source as? T {
            return .success(value)
        }
        if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
            return .success(value)
        }
        let key = "\(T.self)"
        if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
           return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
    static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
        return .success(decoded.value)
    }

    static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        if let source = source, !(source is NSNull) {
            switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
            case let .success(value): return .success(value)
            case let .failure(error): return .failure(error)
            }
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> where T: RawRepresentable {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decodeOptional(clazz: T.self, source: sourceValue) {
                case let .success(value): if let value = value { values.append(value) }
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value): values.append(value)
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value): dictionary[key] = value
                case let .failure(error): return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T: RawRepresentable, U: AnyObject>(clazz: T, source: AnyObject) -> Decoded<T?> where T.RawValue == U {
        if let value = source as? U {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
        }
    }


    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.dateFormat = format
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return .success(date)
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
            }
            if source is String || source is Int {
                return .failure(.parseError(message: "Could not decode date"))
            } else {
                return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
            }
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return .success(isoDate)
            } else {
            	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
            }
        }

        // Decoder for [AnyOfbody1ParrotsItems]
        Decoders.addDecoder(clazz: [AnyOfbody1ParrotsItems].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AnyOfbody1ParrotsItems]> in
            return Decoders.decode(clazz: [AnyOfbody1ParrotsItems].self, source: source)
        }

        // Decoder for AnyOfbody1ParrotsItems
        Decoders.addDecoder(clazz: AnyOfbody1ParrotsItems.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AnyOfbody1ParrotsItems> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AnyOfbody1ParrotsItems()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AnyOfbody1ParrotsItems", actual: "\(source)"))
            }
        }
        // Decoder for [AnyOfbody2]
        Decoders.addDecoder(clazz: [AnyOfbody2].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AnyOfbody2]> in
            return Decoders.decode(clazz: [AnyOfbody2].self, source: source)
        }

        // Decoder for AnyOfbody2
        Decoders.addDecoder(clazz: AnyOfbody2.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AnyOfbody2> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AnyOfbody2()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AnyOfbody2", actual: "\(source)"))
            }
        }
        // Decoder for [ApiResponse]
        Decoders.addDecoder(clazz: [ApiResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ApiResponse]> in
            return Decoders.decode(clazz: [ApiResponse].self, source: source)
        }

        // Decoder for ApiResponse
        Decoders.addDecoder(clazz: ApiResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ApiResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ApiResponse()
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["code"] as AnyObject?) {
                case let .success(value): _result.code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                case let .success(value): _result.type = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                case let .success(value): _result.message = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ApiResponse", actual: "\(source)"))
            }
        }
        // Decoder for [Body]
        Decoders.addDecoder(clazz: [Body].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Body]> in
            return Decoders.decode(clazz: [Body].self, source: source)
        }

        // Decoder for Body
        Decoders.addDecoder(clazz: Body.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Body> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Body()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Body", actual: "\(source)"))
            }
        }
        // Decoder for [Body1]
        Decoders.addDecoder(clazz: [Body1].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Body1]> in
            return Decoders.decode(clazz: [Body1].self, source: source)
        }

        // Decoder for Body1
        Decoders.addDecoder(clazz: Body1.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Body1> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Body1()
                switch Decoders.decodeOptional(clazz: [AnyOfbody1ParrotsItems].self, source: sourceDictionary["parrots"] as AnyObject?) {
                case let .success(value): _result.parrots = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Body1", actual: "\(source)"))
            }
        }
        // Decoder for [Body2]
        Decoders.addDecoder(clazz: [Body2].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Body2]> in
            return Decoders.decode(clazz: [Body2].self, source: source)
        }

        // Decoder for Body2
        Decoders.addDecoder(clazz: Body2.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Body2> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Body2()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Body2", actual: "\(source)"))
            }
        }
        // Decoder for [Cat]
        Decoders.addDecoder(clazz: [Cat].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Cat]> in
            return Decoders.decode(clazz: [Cat].self, source: source)
        }

        // Decoder for Cat
        Decoders.addDecoder(clazz: Cat.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Cat> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "Cat", actual: "\(nameSource)"))
                }
                let _result = Cat(name: name)
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                case let .success(value): _result.id = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Cat.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Object].self, source: sourceDictionary["part"] as AnyObject?) {
                case let .success(value): _result.part = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["hunts"] as AnyObject?) {
                case let .success(value): _result.hunts = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["age"] as AnyObject?) {
                case let .success(value): _result.age = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Cat", actual: "\(source)"))
            }
        }
        // Decoder for [Category]
        Decoders.addDecoder(clazz: [Category].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Category]> in
            return Decoders.decode(clazz: [Category].self, source: source)
        }

        // Decoder for Category
        Decoders.addDecoder(clazz: Category.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Category> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Category()
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                case let .success(value): _result.id = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Category].self, source: sourceDictionary["subcategories"] as AnyObject?) {
                case let .success(value): _result.subcategories = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Category", actual: "\(source)"))
            }
        }
        // Decoder for [Dog]
        Decoders.addDecoder(clazz: [Dog].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Dog]> in
            return Decoders.decode(clazz: [Dog].self, source: source)
        }

        // Decoder for Dog
        Decoders.addDecoder(clazz: Dog.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Dog> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "Dog", actual: "\(nameSource)"))
                }
                let _result = Dog(name: name)
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                case let .success(value): _result.id = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Dog.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Object].self, source: sourceDictionary["part"] as AnyObject?) {
                case let .success(value): _result.part = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["bark"] as AnyObject?) {
                case let .success(value): _result.bark = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Dog.Breed.self, source: sourceDictionary["breed"] as AnyObject?) {
                case let .success(value): _result.breed = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Dog", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse200]
        Decoders.addDecoder(clazz: [InlineResponse200].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse200]> in
            return Decoders.decode(clazz: [InlineResponse200].self, source: source)
        }

        // Decoder for InlineResponse200
        Decoders.addDecoder(clazz: InlineResponse200.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse200> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = InlineResponse200()
                switch Decoders.decodeOptional(clazz: [OneOfinlineResponse200ParrotsItems].self, source: sourceDictionary["parrots"] as AnyObject?) {
                case let .success(value): _result.parrots = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse200", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse2001]
        Decoders.addDecoder(clazz: [InlineResponse2001].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse2001]> in
            return Decoders.decode(clazz: [InlineResponse2001].self, source: source)
        }

        // Decoder for InlineResponse2001
        Decoders.addDecoder(clazz: InlineResponse2001.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse2001> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = InlineResponse2001()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse2001", actual: "\(source)"))
            }
        }
        // Decoder for [Macaw]
        Decoders.addDecoder(clazz: [Macaw].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Macaw]> in
            return Decoders.decode(clazz: [Macaw].self, source: source)
        }

        // Decoder for Macaw
        Decoders.addDecoder(clazz: Macaw.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Macaw> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Macaw()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["color"] as AnyObject?) {
                case let .success(value): _result.color = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["singer"] as AnyObject?) {
                case let .success(value): _result.singer = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Macaw", actual: "\(source)"))
            }
        }
        // Decoder for [OneOfAllPetsResponseItems]
        Decoders.addDecoder(clazz: [OneOfAllPetsResponseItems].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OneOfAllPetsResponseItems]> in
            return Decoders.decode(clazz: [OneOfAllPetsResponseItems].self, source: source)
        }

        // Decoder for OneOfAllPetsResponseItems
        Decoders.addDecoder(clazz: OneOfAllPetsResponseItems.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OneOfAllPetsResponseItems> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OneOfAllPetsResponseItems()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OneOfAllPetsResponseItems", actual: "\(source)"))
            }
        }
        // Decoder for [OneOfPartMasterDestination]
        Decoders.addDecoder(clazz: [OneOfPartMasterDestination].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OneOfPartMasterDestination]> in
            return Decoders.decode(clazz: [OneOfPartMasterDestination].self, source: source)
        }

        // Decoder for OneOfPartMasterDestination
        Decoders.addDecoder(clazz: OneOfPartMasterDestination.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OneOfPartMasterDestination> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OneOfPartMasterDestination()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OneOfPartMasterDestination", actual: "\(source)"))
            }
        }
        // Decoder for [OneOfPartMasterOrigin]
        Decoders.addDecoder(clazz: [OneOfPartMasterOrigin].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OneOfPartMasterOrigin]> in
            return Decoders.decode(clazz: [OneOfPartMasterOrigin].self, source: source)
        }

        // Decoder for OneOfPartMasterOrigin
        Decoders.addDecoder(clazz: OneOfPartMasterOrigin.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OneOfPartMasterOrigin> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OneOfPartMasterOrigin()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OneOfPartMasterOrigin", actual: "\(source)"))
            }
        }
        // Decoder for [OneOfPetPartItems]
        Decoders.addDecoder(clazz: [OneOfPetPartItems].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OneOfPetPartItems]> in
            return Decoders.decode(clazz: [OneOfPetPartItems].self, source: source)
        }

        // Decoder for OneOfPetPartItems
        Decoders.addDecoder(clazz: OneOfPetPartItems.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OneOfPetPartItems> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OneOfPetPartItems()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OneOfPetPartItems", actual: "\(source)"))
            }
        }
        // Decoder for [OneOfPup]
        Decoders.addDecoder(clazz: [OneOfPup].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OneOfPup]> in
            return Decoders.decode(clazz: [OneOfPup].self, source: source)
        }

        // Decoder for OneOfPup
        Decoders.addDecoder(clazz: OneOfPup.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OneOfPup> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OneOfPup()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OneOfPup", actual: "\(source)"))
            }
        }
        // Decoder for [OneOfinlineResponse2001]
        Decoders.addDecoder(clazz: [OneOfinlineResponse2001].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OneOfinlineResponse2001]> in
            return Decoders.decode(clazz: [OneOfinlineResponse2001].self, source: source)
        }

        // Decoder for OneOfinlineResponse2001
        Decoders.addDecoder(clazz: OneOfinlineResponse2001.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OneOfinlineResponse2001> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OneOfinlineResponse2001()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OneOfinlineResponse2001", actual: "\(source)"))
            }
        }
        // Decoder for [OneOfinlineResponse200ParrotsItems]
        Decoders.addDecoder(clazz: [OneOfinlineResponse200ParrotsItems].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OneOfinlineResponse200ParrotsItems]> in
            return Decoders.decode(clazz: [OneOfinlineResponse200ParrotsItems].self, source: source)
        }

        // Decoder for OneOfinlineResponse200ParrotsItems
        Decoders.addDecoder(clazz: OneOfinlineResponse200ParrotsItems.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OneOfinlineResponse200ParrotsItems> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OneOfinlineResponse200ParrotsItems()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OneOfinlineResponse200ParrotsItems", actual: "\(source)"))
            }
        }
        // Decoder for [OneOfvalMembersValMemberItems]
        Decoders.addDecoder(clazz: [OneOfvalMembersValMemberItems].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OneOfvalMembersValMemberItems]> in
            return Decoders.decode(clazz: [OneOfvalMembersValMemberItems].self, source: source)
        }

        // Decoder for OneOfvalMembersValMemberItems
        Decoders.addDecoder(clazz: OneOfvalMembersValMemberItems.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OneOfvalMembersValMemberItems> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OneOfvalMembersValMemberItems()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OneOfvalMembersValMemberItems", actual: "\(source)"))
            }
        }
        // Decoder for [Order]
        Decoders.addDecoder(clazz: [Order].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Order]> in
            return Decoders.decode(clazz: [Order].self, source: source)
        }

        // Decoder for Order
        Decoders.addDecoder(clazz: Order.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Order> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Order()
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                case let .success(value): _result.id = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["petId"] as AnyObject?) {
                case let .success(value): _result.petId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["quantity"] as AnyObject?) {
                case let .success(value): _result.quantity = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["shipDate"] as AnyObject?) {
                case let .success(value): _result.shipDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Order.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["complete"] as AnyObject?) {
                case let .success(value): _result.complete = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Order", actual: "\(source)"))
            }
        }
        // Decoder for [Parakeet]
        Decoders.addDecoder(clazz: [Parakeet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Parakeet]> in
            return Decoders.decode(clazz: [Parakeet].self, source: source)
        }

        // Decoder for Parakeet
        Decoders.addDecoder(clazz: Parakeet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Parakeet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Parakeet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["color"] as AnyObject?) {
                case let .success(value): _result.color = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["soundRepeater"] as AnyObject?) {
                case let .success(value): _result.soundRepeater = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Parakeet", actual: "\(source)"))
            }
        }
        // Decoder for [PartFour]
        Decoders.addDecoder(clazz: [PartFour].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PartFour]> in
            return Decoders.decode(clazz: [PartFour].self, source: source)
        }

        // Decoder for PartFour
        Decoders.addDecoder(clazz: PartFour.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PartFour> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PartFour()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["otherIdPart"] as AnyObject?) {
                case let .success(value): _result.otherIdPart = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PartFour", actual: "\(source)"))
            }
        }
        // Decoder for [PartMaster]
        Decoders.addDecoder(clazz: [PartMaster].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PartMaster]> in
            return Decoders.decode(clazz: [PartMaster].self, source: source)
        }

        // Decoder for PartMaster
        Decoders.addDecoder(clazz: PartMaster.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PartMaster> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PartMaster()
                switch Decoders.decodeOptional(clazz: OneOfPartMasterDestination.self, source: sourceDictionary["destination"] as AnyObject?) {
                case let .success(value): _result.destination = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OneOfPartMasterOrigin.self, source: sourceDictionary["origin"] as AnyObject?) {
                case let .success(value): _result.origin = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PartMaster", actual: "\(source)"))
            }
        }
        // Decoder for [PartOne]
        Decoders.addDecoder(clazz: [PartOne].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PartOne]> in
            return Decoders.decode(clazz: [PartOne].self, source: source)
        }

        // Decoder for PartOne
        Decoders.addDecoder(clazz: PartOne.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PartOne> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PartOne()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PartOne", actual: "\(source)"))
            }
        }
        // Decoder for [PartThree]
        Decoders.addDecoder(clazz: [PartThree].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PartThree]> in
            return Decoders.decode(clazz: [PartThree].self, source: source)
        }

        // Decoder for PartThree
        Decoders.addDecoder(clazz: PartThree.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PartThree> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PartThree()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["otherId"] as AnyObject?) {
                case let .success(value): _result.otherId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PartThree", actual: "\(source)"))
            }
        }
        // Decoder for [PartTwo]
        Decoders.addDecoder(clazz: [PartTwo].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PartTwo]> in
            return Decoders.decode(clazz: [PartTwo].self, source: source)
        }

        // Decoder for PartTwo
        Decoders.addDecoder(clazz: PartTwo.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PartTwo> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PartTwo()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                case let .success(value): _result.id = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PartTwo", actual: "\(source)"))
            }
        }
        // Decoder for [Pet]
        Decoders.addDecoder(clazz: [Pet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Pet]> in
            return Decoders.decode(clazz: [Pet].self, source: source)
        }

        // Decoder for Pet
        Decoders.addDecoder(clazz: Pet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Pet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "Pet", actual: "\(nameSource)"))
                }
                let _result = Pet(name: name)
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                case let .success(value): _result.id = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Pet.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OneOfPetPartItems].self, source: sourceDictionary["part"] as AnyObject?) {
                case let .success(value): _result.part = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Pet", actual: "\(source)"))
            }
        }
        // Decoder for [Pup]
        Decoders.addDecoder(clazz: [Pup].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Pup]> in
            return Decoders.decode(clazz: [Pup].self, source: source)
        }

        // Decoder for Pup
        Decoders.addDecoder(clazz: Pup.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Pup> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Pup()
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                case let .success(value): _result.id = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Pup", actual: "\(source)"))
            }
        }
        // Decoder for [Tag]
        Decoders.addDecoder(clazz: [Tag].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Tag]> in
            return Decoders.decode(clazz: [Tag].self, source: source)
        }

        // Decoder for Tag
        Decoders.addDecoder(clazz: Tag.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Tag> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Tag()
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                case let .success(value): _result.id = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Tag", actual: "\(source)"))
            }
        }
        // Decoder for [Test]
        Decoders.addDecoder(clazz: [Test].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Test]> in
            return Decoders.decode(clazz: [Test].self, source: source)
        }

        // Decoder for Test
        Decoders.addDecoder(clazz: Test.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Test> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Test()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Test", actual: "\(source)"))
            }
        }
        // Decoder for [User]
        Decoders.addDecoder(clazz: [User].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[User]> in
            return Decoders.decode(clazz: [User].self, source: source)
        }

        // Decoder for User
        Decoders.addDecoder(clazz: User.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<User> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = User()
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                case let .success(value): _result.id = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                case let .success(value): _result.username = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["firstName"] as AnyObject?) {
                case let .success(value): _result.firstName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lastName"] as AnyObject?) {
                case let .success(value): _result.lastName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                case let .success(value): _result.email = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                case let .success(value): _result.password = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone"] as AnyObject?) {
                case let .success(value): _result.phone = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["userStatus"] as AnyObject?) {
                case let .success(value): _result.userStatus = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "User", actual: "\(source)"))
            }
        }
        // Decoder for [ValMemberChoice1]
        Decoders.addDecoder(clazz: [ValMemberChoice1].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ValMemberChoice1]> in
            return Decoders.decode(clazz: [ValMemberChoice1].self, source: source)
        }

        // Decoder for ValMemberChoice1
        Decoders.addDecoder(clazz: ValMemberChoice1.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ValMemberChoice1> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let valDateOfBirthSource = sourceDictionary["val_date_of_birth"] as AnyObject? else {
                    return .failure(.missingKey(key: "val_date_of_birth"))
                }
                guard let valDateOfBirth = Decoders.decode(clazz: ISOFullDate.self.self, source: valDateOfBirthSource).value else {
                    return .failure(.typeMismatch(expected: "ValMemberChoice1", actual: "\(valDateOfBirthSource)"))
                }
                let _result = ValMemberChoice1(valDateOfBirth: valDateOfBirth)
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["val_leaving_date"] as AnyObject?) {
                case let .success(value): _result.valLeavingDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ValMemberChoice1", actual: "\(source)"))
            }
        }
        // Decoder for [ValMemberChoice2]
        Decoders.addDecoder(clazz: [ValMemberChoice2].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ValMemberChoice2]> in
            return Decoders.decode(clazz: [ValMemberChoice2].self, source: source)
        }

        // Decoder for ValMemberChoice2
        Decoders.addDecoder(clazz: ValMemberChoice2.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ValMemberChoice2> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ValMemberChoice2()
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["val_leaving_date"] as AnyObject?) {
                case let .success(value): _result.valLeavingDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ValMemberChoice2", actual: "\(source)"))
            }
        }
        // Decoder for [ValMembers]
        Decoders.addDecoder(clazz: [ValMembers].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ValMembers]> in
            return Decoders.decode(clazz: [ValMembers].self, source: source)
        }

        // Decoder for ValMembers
        Decoders.addDecoder(clazz: ValMembers.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ValMembers> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let valMemberSource = sourceDictionary["val_member"] as AnyObject? else {
                    return .failure(.missingKey(key: "val_member"))
                }
                guard let valMember = Decoders.decode(clazz: [OneOfvalMembersValMemberItems].self.self, source: valMemberSource).value else {
                    return .failure(.typeMismatch(expected: "ValMembers", actual: "\(valMemberSource)"))
                }
                let _result = ValMembers(valMember: valMember)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ValMembers", actual: "\(source)"))
            }
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
