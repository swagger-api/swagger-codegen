/**
* Swagger Petstore
* This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\
*
* OpenAPI spec version: 1.0.0
* Contact: apiteam@swagger.io
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/

package io.swagger.client.infrastructure


import io.swagger.client.models.*

import com.google.gson.*
import com.google.gson.internal.bind.util.ISO8601Utils
import com.google.gson.stream.JsonReader
import com.google.gson.stream.JsonToken
import com.google.gson.stream.JsonWriter
import io.gsonfire.GsonFireBuilder
import java.text.DateFormat
import java.text.ParseException
import java.text.ParsePosition
import java.time.LocalDate
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter
import java.util.*

class JSON {
    var gson: Gson
    private val dateTypeAdapter = DateTypeAdapter()
    private val sqlDateTypeAdapter = SqlDateTypeAdapter()
    private val offsetDateTimeTypeAdapter = OffsetDateTimeTypeAdapter()
    private val localDateTypeAdapter = LocalDateTypeAdapter()

    companion object {
        fun createGson(): GsonBuilder {
            val fireBuilder = GsonFireBuilder()
                .registerTypeSelector(Animal::class.java, {
                        val classByDiscriminatorValue = mapOf(
                                "Dog".toUpperCase() to Dog::class.java,
                                "Cat".toUpperCase() to Cat::class.java,
                                "Animal".toUpperCase() to Animal::class.java)
                        getClassByDiscriminator(
                                classByDiscriminatorValue,
                                getDiscriminatorValue(it, "className"))
                })

            return fireBuilder.createGsonBuilder()
        }

        private fun getDiscriminatorValue(readElement: JsonElement, discriminatorField: String): String {
            val element = readElement.asJsonObject[discriminatorField]
                    ?: throw IllegalArgumentException("missing discriminator field: <$discriminatorField>")
            return element.asString
        }

        @Suppress("UNCHECKED_CAST")
        private fun <T> getClassByDiscriminator(classByDiscriminatorValue: Map<String, Class<*>>, discriminatorValue: String): Class<out T> {
            return classByDiscriminatorValue[discriminatorValue.toUpperCase()] as Class<T>?
                    ?: throw IllegalArgumentException("cannot determine model class of name: <$discriminatorValue>")
        }

    }


    init {
        gson = createGson()
                .registerTypeAdapter(Date::class.java, dateTypeAdapter)
                .registerTypeAdapter(java.sql.Date::class.java, sqlDateTypeAdapter)
                .registerTypeAdapter(OffsetDateTime::class.java, offsetDateTimeTypeAdapter)
                .registerTypeAdapter(LocalDate::class.java, localDateTypeAdapter)
                .create()
    }

    fun setOffsetDateTimeFormat(dateFormat: DateTimeFormatter): JSON {
        offsetDateTimeTypeAdapter.formatter = dateFormat
        return this
    }

    fun setLocalDateFormat(dateFormat: DateTimeFormatter): JSON {
        localDateTypeAdapter.formatter = dateFormat
        return this
    }

    fun setDateFormat(dateFormat: DateFormat): JSON {
        dateTypeAdapter.dateFormat = dateFormat
        return this
    }

    fun setSqlDateFormat(dateFormat: DateFormat): JSON {
        sqlDateTypeAdapter.dateFormat = dateFormat
        return this
    }

}

/**
 * Gson TypeAdapter for JSR310 OffsetDateTime type
 */
class OffsetDateTimeTypeAdapter(var formatter: DateTimeFormatter) : TypeAdapter<OffsetDateTime>() {

    constructor() : this(DateTimeFormatter.ISO_OFFSET_DATE_TIME)

    override fun write(out: JsonWriter, date: OffsetDateTime?) {
        if (date == null) {
            out.nullValue()
        } else {
            out.value(formatter.format(date))
        }
    }

    override fun read(reader: JsonReader): OffsetDateTime? {
        return when (reader.peek()) {
            JsonToken.NULL -> {
                reader.nextNull()
                null
            }
            else -> {
                var date = reader.nextString()
                if (date.endsWith("+0000")) {
                    date = date.substring(0, date.length - 5) + "Z"
                }
                OffsetDateTime.parse(date, formatter)
            }
        }
    }
}

/**
 * Gson TypeAdapter for JSR310 LocalDate type
 */
class LocalDateTypeAdapter(var formatter: DateTimeFormatter) : TypeAdapter<LocalDate>() {

    constructor() : this(DateTimeFormatter.ISO_OFFSET_DATE_TIME)

    override fun write(out: JsonWriter, date: LocalDate?) {
        if (date == null) {
            out.nullValue()
        } else {
            out.value(formatter.format(date))
        }
    }

    override fun read(reader: JsonReader): LocalDate? {
        return when (reader.peek()) {
            JsonToken.NULL -> {
                reader.nextNull()
                null
            }
            else -> {
                val date = reader.nextString()
                LocalDate.parse(date, formatter)
            }
        }
    }
}

/**
 * Gson TypeAdapter for java.sql.Date type
 * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
 * (more efficient than SimpleDateFormat).
 */
class SqlDateTypeAdapter(var dateFormat: DateFormat? = null) : TypeAdapter<java.sql.Date>() {

    override fun write(out: JsonWriter, date: java.sql.Date?) {
        if (date == null) {
            out.nullValue()
        } else {
            val value = dateFormat?.format(date) ?: date.toString()
            out.value(value)
        }
    }

    override fun read(reader: JsonReader): java.sql.Date? {
        return when (reader.peek()) {
            JsonToken.NULL -> {
                reader.nextNull()
                null
            }
            else -> {
                val date = reader.nextString()
                try {
                    return dateFormat?.let { java.sql.Date(it.parse(date).time) }
                            ?: java.sql.Date(ISO8601Utils.parse(date, ParsePosition(0)).time)
                } catch (e: ParseException) {
                    throw JsonParseException(e)
                }
            }
        }
    }
}

/**
 * Gson TypeAdapter for java.util.Date type
 * If the dateFormat is null, ISO8601Utils will be used.
 */
class DateTypeAdapter(var dateFormat: DateFormat? = null) : TypeAdapter<Date>() {

    override fun write(out: JsonWriter, date: Date?) {
        if (date == null) {
            out.nullValue()
        } else {
            val value = dateFormat?.format(date) ?: ISO8601Utils.format(date, true)
            out.value(value)
        }
    }

    override fun read(reader: JsonReader): Date? {
        try {
            return when (reader.peek()) {
                JsonToken.NULL -> {
                    reader.nextNull()
                    null
                }
                else -> {
                    val date = reader.nextString()
                    try {
                        return dateFormat?.let { java.sql.Date(it.parse(date).time) }
                                ?: java.sql.Date(ISO8601Utils.parse(date, ParsePosition(0)).time)
                    } catch (e: ParseException) {
                        throw JsonParseException(e)
                    }
                }
            }
        } catch (e: IllegalArgumentException) {
            throw JsonParseException(e)
        }

    }
}
